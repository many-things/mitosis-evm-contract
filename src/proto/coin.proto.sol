// File automatically generated by protoc-gen-sol unspecified version
// SPDX-License-Identifier: Apache-2.0
pragma solidity >=0.6.0 <8.0.0;
pragma experimental ABIEncoderV2;

import "@p2s/ProtobufLib.sol";

struct Coin {
    string denom;
    string amount;
}

library CoinCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len)
        internal
        pure
        returns (bool, uint64, Coin memory)
    {
        // Message instance
        Coin memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 2) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, Coin memory instance)
        internal
        pure
        returns (bool, uint64)
    {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // Coin.denom
    function decode_1(uint64 pos, bytes memory buf, Coin memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.denom = v;

        return (true, pos);
    }

    // Coin.amount
    function decode_2(uint64 pos, bytes memory buf, Coin memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.amount = v;

        return (true, pos);
    }

    // Holds encoded version of message
    struct Coin__Encoded {
        bytes denom__Key;
        bytes denom__Length;
        bytes denom;
        bytes amount__Key;
        bytes amount__Length;
        bytes amount;
    }

    // Holds encoded version of nested message
    struct Coin__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(Coin memory instance) internal pure returns (bytes memory) {
        Coin__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding denom if default value
        if (bytes(instance.denom).length > 0) {
            // Encode key for denom
            encodedInstance.denom__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode denom
            encodedInstance.denom__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.denom).length));
            encodedInstance.denom = bytes(instance.denom);
        }

        // Omit encoding amount if default value
        if (bytes(instance.amount).length > 0) {
            // Encode key for amount
            encodedInstance.amount__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode amount
            encodedInstance.amount__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.amount).length));
            encodedInstance.amount = bytes(instance.amount);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.denom.length);
        len += uint64(encodedInstance.amount.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.denom.length) {
            finalEncoded[index++] = encodedInstance.denom[j++];
        }
        j = 0;
        while (j < encodedInstance.amount.length) {
            finalEncoded[index++] = encodedInstance.amount[j++];
        }

        return finalEncoded;
    }

    // Encode a nested Coin, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, Coin memory instance)
        internal
        pure
        returns (Coin__Encoded__Nested memory)
    {
        Coin__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }
}
