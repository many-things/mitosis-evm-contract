// File automatically generated by protoc-gen-sol unspecified version
// SPDX-License-Identifier: Apache-2.0
pragma solidity >=0.6.0 <8.0.0;
pragma experimental ABIEncoderV2;

import "@p2s/ProtobufLib.sol";
import "./coin.proto.sol";

struct MsgSend {
    string from_address;
    string to_address;
    Coin[] amount;
}

library MsgSendCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len)
        internal
        pure
        returns (bool, uint64, MsgSend memory)
    {
        // Message instance
        MsgSend memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 3) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(
        uint64 initial_pos,
        bytes memory buf,
        uint64 len,
        uint64 field_number,
        MsgSend memory instance
    ) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // MsgSend.from_address
    function decode_1(uint64 pos, bytes memory buf, MsgSend memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.from_address = v;

        return (true, pos);
    }

    // MsgSend.to_address
    function decode_2(uint64 pos, bytes memory buf, MsgSend memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.to_address = v;

        return (true, pos);
    }

    // MsgSend.amount
    function decode_3(uint64 pos, bytes memory buf, MsgSend memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 initial_pos = pos;

        // Do one pass to count the number of elements
        uint64 cnt = 0;
        while (pos < buf.length) {
            uint64 len;
            (success, pos, len) = ProtobufLib.decode_embedded_message(pos, buf);
            if (!success) {
                return (false, pos);
            }

            // Sanity checks
            if (pos + len < pos) {
                return (false, pos);
            }

            pos += len;
            cnt += 1;

            if (pos >= buf.length) {
                break;
            }

            // Decode next key
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos);
            }

            // Check if the field number is different
            if (field_number != 3) {
                break;
            }
        }

        // Allocated memory
        instance.amount = new Coin[](cnt);

        // Now actually parse the elements
        pos = initial_pos;
        for (uint64 i = 0; i < cnt; i++) {
            uint64 len;
            (success, pos, len) = ProtobufLib.decode_embedded_message(pos, buf);
            if (!success) {
                return (false, pos);
            }

            initial_pos = pos;

            Coin memory nestedInstance;
            (success, pos, nestedInstance) = CoinCodec.decode(pos, buf, len);
            if (!success) {
                return (false, pos);
            }

            instance.amount[i] = nestedInstance;

            // Skip over next key, reuse len
            if (i < cnt - 1) {
                (success, pos, len) = ProtobufLib.decode_uint64(pos, buf);
                if (!success) {
                    return (false, pos);
                }
            }
        }

        return (true, pos);
    }

    // Holds encoded version of message
    struct MsgSend__Encoded {
        bytes from_address__Key;
        bytes from_address__Length;
        bytes from_address;
        bytes to_address__Key;
        bytes to_address__Length;
        bytes to_address;
        CoinCodec.Coin__Encoded__Nested[] amount;
        bytes amount__Encoded;
    }

    // Holds encoded version of nested message
    struct MsgSend__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(MsgSend memory instance) internal pure returns (bytes memory) {
        MsgSend__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding from_address if default value
        if (bytes(instance.from_address).length > 0) {
            // Encode key for from_address
            encodedInstance.from_address__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode from_address
            encodedInstance.from_address__Length =
                ProtobufLib.encode_uint64(uint64(bytes(instance.from_address).length));
            encodedInstance.from_address = bytes(instance.from_address);
        }

        // Omit encoding to_address if default value
        if (bytes(instance.to_address).length > 0) {
            // Encode key for to_address
            encodedInstance.to_address__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode to_address
            encodedInstance.to_address__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.to_address).length));
            encodedInstance.to_address = bytes(instance.to_address);
        }

        // Encode amount
        len = 0;
        encodedInstance.amount = new CoinCodec.Coin__Encoded__Nested[](instance.amount.length);
        for (uint64 i = 0; i < instance.amount.length; i++) {
            encodedInstance.amount[i] = CoinCodec.encodeNested(3, instance.amount[i]);
            len += uint64(
                encodedInstance.amount[i].key.length + encodedInstance.amount[i].length.length
                    + encodedInstance.amount[i].nestedInstance.length
            );
        }

        encodedInstance.amount__Encoded = new bytes(len);
        index = 0;
        for (uint64 i = 0; i < instance.amount.length; i++) {
            uint64 j = 0;
            while (j < encodedInstance.amount[i].key.length) {
                encodedInstance.amount__Encoded[index++] = encodedInstance.amount[i].key[j++];
            }
            j = 0;
            while (j < encodedInstance.amount[i].length.length) {
                encodedInstance.amount__Encoded[index++] = encodedInstance.amount[i].length[j++];
            }
            j = 0;
            while (j < encodedInstance.amount[i].nestedInstance.length) {
                encodedInstance.amount__Encoded[index++] = encodedInstance.amount[i].nestedInstance[j++];
            }
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.from_address.length);
        len += uint64(encodedInstance.to_address.length);
        len += uint64(encodedInstance.amount__Encoded.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.from_address.length) {
            finalEncoded[index++] = encodedInstance.from_address[j++];
        }
        j = 0;
        while (j < encodedInstance.to_address.length) {
            finalEncoded[index++] = encodedInstance.to_address[j++];
        }
        j = 0;
        while (j < encodedInstance.amount__Encoded.length) {
            finalEncoded[index++] = encodedInstance.amount__Encoded[j++];
        }

        return finalEncoded;
    }

    // Encode a nested MsgSend, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, MsgSend memory instance)
        internal
        pure
        returns (MsgSend__Encoded__Nested memory)
    {
        MsgSend__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }
}
